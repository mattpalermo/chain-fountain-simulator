<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Chain fountain simulator</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <style>
    body {
      background-size: 20px 20px;
      background-image:
        linear-gradient(to right, lavender 1px, transparent 1px),
        linear-gradient(to bottom, lavender 1px, transparent 1px);
      font-family: Verdana, Arial, Helvetica, sans-serif;
      margin: 0;
      padding: 0;
    }

    #header {
      box-sizing: border-box;
      width: 100%;
      height: 2em;
      padding: 0.3em 0.5em;
      margin: 0;
      display: flex;
      align-items: center;
      background-color: linen;
      box-shadow: 0px 0px 5px black;
    }

    #simulation-canvas {
      box-sizing: border-box;
      width: 100%;
      height: calc(100vh - 4em);
      margin: 0;
      padding: 0;
      display: block;
    }

    #parameters {
      position: absolute;
      top: 3em;
      right: 1em;
      box-sizing: border-box;
      width: 20em;
      max-width: calc(100vw - 2em);
      max-height: 100vh;
      overflow: auto;
      background-color: white;
      box-shadow: 2px 2px 5px black;
      padding: 0.5em;
    }
    #parameters .header {
      margin-bottom: 0.3em;
      display: flex;
      align-items: center;
    }
    #parameters h2 { margin-left: 0.5em }
    #parameters .header button {
      width: 2em;
      height: 2em;
      padding: 0;
      margin: 0;
    }
    #parameters label {
      display: block;
      text-align: right;
      margin: 0.2em 0;
    }
    #parameters input { width: 8ch }
    #parameters em {
      font-size: small;
      margin-top: 1em;
      display: block
    }

    #controls {
      box-sizing: border-box;
      overflow: auto;
      width: 100%;
      height: 2em;
      padding: 0;
      margin: 0;
      display: flex;
      align-items: center;
      background-color: linen;
      box-shadow: 0px 0px 2px black;
    }
    #controls > * {margin-left: 0.5em; margin-right: 0.5em}
    #controls label {margin-right: auto }
    #controls input { width: 8ch }

    h1 {
      margin: 0;
      margin-right: auto;
      padding: 0;
      font-size: 1.3em;
      font-weight: normal;
    }
    h2 {
      font-size: 1.2em;
      font-weight: normal;
      margin: 0;
      padding: 0;
    }

    @media (max-width: 25em) {
      #header .extra-content { display: none }
    }
    @media (max-width: 35em) {
      #controls .extra-content { display: none }
    }

  </style>
</head>
<body>
  <div id="header">
    <h1>Chain fountain simulator</h1>
    <a href="https://github.com/mattpalermo/chain-fountain-simulator">
      (?) <span class="extra-content">About</span>
    </a>
  </div>

  <div id="parameters">
    <div class="header">
      <button id="close-parameters" onclick="closeParameters()">‚ùå</button>
      <h2>Parameters</h2>
    </div>
    <label>Bead mass (g):
      <input id="bead-mass" type="number" value="5" step="any" onchange="setParameter()">
    </label>
    <label>Link length (mm):
      <input id="link-length" type="number" value="5" step="any" onchange="setParameter()">
    </label>
    <label>Initial height (m):
      <input id="initial-height" type="number" value="1" step="any" onchange="setParameter()">
    </label>
    <label>Integration time step (ms):
      <input id="time-step-size" type="number" value="1" step="any" onchange="setParameter()">
    </label>
    <em>Note: changing parameters resets the integration</em>
  </div>

  <canvas id="simulation-canvas"></canvas>

  <div id="controls">
    <button id="toggle-play" onclick="togglePlay()">‚ñ∂Ô∏è</button>
    <label>Time (s):
      <input id="time" type="number" value="0" step="any" min="0" onchange="userSetTime()">
    </label>
    <button id="toggle-parameters" onclick="toggleParameters()">
      ‚öô <span class="extra-content">Parameters</span>
    </button>
    <a id="export" href="" download="mould-integration.json">
      üíæ <span class="extra-content">Export integration data</span>
    </a>
  </div>

  <script>
    // UI elements
    let elParameters = document.getElementById("parameters");
    let elTogglePlay = document.getElementById("toggle-play");
    let elTime = document.getElementById("time");
    let elBeadMass = document.getElementById("bead-mass");
    let elLinkLength = document.getElementById("link-length");
    let elInitialHeight = document.getElementById("initial-height");
    let elTimeStepSize = document.getElementById("time-step-size");
    let elCanvas = document.getElementById("simulation-canvas");
    let ctx = elCanvas.getContext("2d");

    // Constants
    let platformWidth = 0.02;
    let platformHeight = 0.02;
    let platformColour = "#000000";
    let beadRadius = 0.01;
    let beadColour = "#FF0000";
    let linkWidth = 0.005
    let linkColour = "#0000FF";

    // Global variables
    let currentIntegration;
    let lastFrameTime;
    let curAnimationTime = 0; // This time might not coincide with an integration step.
    let animationPlaying = false;
    let firstFrame = true;

    // When the toggle parameters UI button is clicked
    function toggleParameters() {
      if(elParameters.style.visibility === "hidden") {
        elParameters.style.visibility = "visible";
      } else {
        elParameters.style.visibility = "hidden";
      }
    }

    // When the close parameters UI button is clicked
    function closeParameters() {
      elParameters.style.visibility = "hidden";
    }

    // When one of the parameters are set
    function setParameter() {
      setCurrentIntegration(newIntegration());
    }

    // When the UI play button is clicked
    function togglePlay() {
      if (animationPlaying) {
        pauseAnimation();
      } else {
        playAnimation();
      }
    }

    function playAnimation() {
      animationPlaying = true;
      firstFrame = true;
      elTogglePlay.innerHTML = "‚è∏";
    }

    function pauseAnimation() {
      animationPlaying = false;
      elTogglePlay.innerHTML = "‚ñ∂Ô∏è";
    }

    function setAnimationTime(time) {
      curAnimationTime = time;
      if (currentIntegration) {
        let timeStepSize = currentIntegration.parameters.timeStepSize;
        let timeIndex = Math.floor(time / timeStepSize);
        time = timeIndex * timeStepSize;
      }
      elTime.value = time;
    }

    // When the UI time value is changed by the user
    function userSetTime() {
      let time = Number(elTime.value);
      if (time < 0) time = 0;
      setAnimationTime(time);
    }

    /**
    START INTEGRATION MATH
    **/

    // Create an object representing a whole integration
    function newIntegration() {
      let beadMass = Number(elBeadMass.value);
      let linkLength = Number(elLinkLength.value) / 1000;
      let initialHeight = Number(elInitialHeight.value);
      let timeStepSize = Number(elTimeStepSize.value) / 1000;
      let gravity = 9.8 // m.s**-2
      // Link stiffness (s**-2.g**-1) derived from k=F/dx where k is the link
      // stiffness, F is a known force (gravity) and dx is a known displacement
      // (half the link length). Basically, under gravity, the link should stretch
      // to 1.5 * link length.
      let linkStiffness = (gravity / beadMass) / (0.1 * linkLength);

      return {
        parameters: {
          beadMass: beadMass,
          linkLength: linkLength,
          initialHeight: initialHeight,
          timeStepSize: timeStepSize,
          gravity: gravity,
          linkStiffness: linkStiffness
        },
        timeSteps: [
          {
            beads: [
              {
                x: 0,
                y: initialHeight,
                vx: 5,
                vy: 5,
                ax: 0, // Used and populated during integration
                ay: 0 // Used and populated during integration
              }
            ]
          }
        ]
      };
    }

    // Integrate one time step. Modifies existing integration object.
    function integrate(integration) {
      // Add a new timeStep object to integration.timeSteps array
      let params = integration.parameters;

      let timeSteps = integration.timeSteps;
      let curTimeStep = timeSteps[timeSteps.length - 1];
      let curBeads = curTimeStep.beads;
      let newTimeStep = { beads: [] };

      if (timeSteps.length < 10) {
        console.log("Time: " + timeSteps.length - 1);
        console.log(curBeads);
      }

      // Find forces acting on each bead
      for (let i = 0; i < curBeads.length; i++) {
        // gravity
        curBeads[i].ay += -params.gravity;

        // Link tension
        if (i < curBeads.length - 1) {
          let dx = curBeads[i+1].x - curBeads[i].x;
          let dy = curBeads[i+1].y - curBeads[i].y;
          let linkLength = Math.sqrt(dx**2 + dy**2);
          let linkDisplacement = linkLength - params.linkLength;
          if (linkDisplacement > 0) {
            curBeads[i].ax += params.linkStiffness * dx / params.beadMass;
            curBeads[i].ay += params.linkStiffness * dy / params.beadMass;
            curBeads[i+1].ax -= params.linkStiffness * dx / params.beadMass;
            curBeads[i+1].ay -= params.linkStiffness * dy / params.beadMass;
          }
        }
      }

      // Integrate bead velocity and position
      newTimeStep.beads = curBeads.map(function(bead) {
        let updatedBead = {
          x: bead.x + bead.vx * params.timeStepSize,
          y: bead.y + bead.vy * params.timeStepSize,
          vx: bead.vx + bead.ax * params.timeStepSize,
          vy: bead.vy + bead.ay * params.timeStepSize,
          ax: 0, // Will be filled out in the next integration
          ay: 0 // Will be filled out in the next integration
        };
        // If the bead hasn't cleared the platform, it can't move below
        // the initial height.
        if (bead.y >= params.initialHeight
          && bead.x <= platformWidth/2 && bead.x >= -platformWidth/2
          && updatedBead.y < params.initialHeight) {
          updatedBead.y = params.initialHeight;
          updatedBead.vy = 0;
        }
        return updatedBead;
      });

      // Spawn new bead if nessesary
      let lastBead = newTimeStep.beads[newTimeStep.beads.length-1];
      let dx = lastBead.x;
      let dy = lastBead.y - params.initialHeight;
      let distFromOrigin = Math.sqrt(dx**2 + dy**2);
      if (distFromOrigin > params.linkLength) {
        newTimeStep.beads.push({
          x: 0, y: params.initialHeight, vx: 0, vy: 0, ax: 0, ay: 0
        });
      }

      // Remove first bead if nessesary
      if(newTimeStep.beads[0].y < 0) {
        newTimeStep.beads.shift();
      }

      integration.timeSteps.push(newTimeStep);
    }

    /**
    END INTEGRATION MATH
    **/

    function integrateUntil(integration, endTimeStep) {
      while (integration.timeSteps.length-1 < endTimeStep) {
        integrate(integration);
      }
    }

    // Draw an integration at a particular time step onto a 2d context
    function draw(integration, timeIndex, ctx) {
      let initialHeight = integration.parameters.initialHeight;
      let timeStep = integration.timeSteps[timeIndex];
      let beads = timeStep.beads;

      // TODO: Do this properly
      ctx.clearRect(-500, -500, 1000, 1000);

      // Draw platform
      ctx.beginPath();
      ctx.rect(-platformWidth/2, initialHeight - platformHeight,
        platformWidth, platformHeight);
      //ctx.rect(-5, -5, 10, 10);
      ctx.fillStyle = platformColour;
      ctx.fill();
      ctx.closePath();

      // Draw floor
      ctx.beginPath();
      ctx.rect(0, 0, ctx.canvas.width, -platformHeight);
      ctx.fillStyle = platformColour;
      ctx.fill();
      ctx.closePath();

      // Draw links
      ctx.beginPath();
      ctx.moveTo(beads[0].x, beads[0].y);
      beads.forEach(function(bead, index) {
        if (index > 0) ctx.lineTo(bead.x, bead.y);
      });
      ctx.lineWidth = linkWidth;
      ctx.strokeStyle = linkColour;
      ctx.stroke();
      ctx.closePath();

      // Draw beads
      ctx.fillStyle = beadColour;
      beads.forEach(function(bead) {
        ctx.beginPath();
        ctx.arc(bead.x, bead.y, beadRadius, 0, Math.PI*2);
        ctx.fill();
        ctx.closePath();
      });
    }

    function onAnimationFrame(frameTime) {
      if (currentIntegration) {

        // If animation is playing progress animation time.
        // Don't progress on first frame since the lastFrameTime could
        // have been very long ago.
        if (animationPlaying) {
          if (!firstFrame && lastFrameTime) {
            setAnimationTime(curAnimationTime + (frameTime - lastFrameTime)/1000);
          } else {
            firstFrame = false;
          }
          lastFrameTime = frameTime;
        }

        let timeStepSize = currentIntegration.parameters.timeStepSize;
        let curTimeIndex = Math.floor(curAnimationTime / timeStepSize);

        integrateUntil(currentIntegration, curTimeIndex);
        draw(currentIntegration, curTimeIndex, ctx);
      }

      window.requestAnimationFrame(onAnimationFrame);
    }

    function setCanvasTransform() {
      if (currentIntegration) {
        let initialHeight = currentIntegration.parameters.initialHeight;
        let scaleFactor = elCanvas.height/(1.5*initialHeight);
        ctx.setTransform(scaleFactor, 0, 0, -scaleFactor, 50, ctx.canvas.height);
      }
    }

    function onCanvasResize() {
      /* NOTE: At the moment, this only fires on window resize,
         which is most likely when the canvas will resize.
         When ResizeObserver gets implemented in browsers,
         use that instead. */

      let canvasRect = elCanvas.getBoundingClientRect();
      elCanvas.width = canvasRect.width;
      elCanvas.height = canvasRect.height;
      setCanvasTransform();
    }

    function setCurrentIntegration(integration) {
      pauseAnimation();
      setAnimationTime(0);
      elTime.step = integration.parameters.timeStepSize;
      currentIntegration = integration;
      setCanvasTransform();
    }

    window.addEventListener("resize", onCanvasResize);
    onCanvasResize();
    setCurrentIntegration(newIntegration());
    window.requestAnimationFrame(onAnimationFrame);

  </script>
</body>
</html>
